{"version":3,"sources":["blotter/rollingDistortMaterial.js"],"names":["Blotter","RollingDistortMaterial","Material","apply","arguments","prototype","Object","create","_extendWithGettersSetters","_mainImageSrc","mainImageSrc","Assets","Shaders","PI","LineMath","Noise","join","constructor","init","mainImage","uniforms","uSineDistortSpread","type","value","uSineDistortCycleCount","uSineDistortAmplitude","uNoiseDistortVolatility","uNoiseDistortAmplitude","uDistortPosition","uRotation","uSpeed"],"mappings":"AAAA,CAAC,UAASA,OAAT,EAAkB;AAEjBA,EAAAA,OAAO,CAACC,sBAAR,GAAiC,YAAW;AAC1CD,IAAAA,OAAO,CAACE,QAAR,CAAiBC,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B;AACD,GAFD;;AAIAJ,EAAAA,OAAO,CAACC,sBAAR,CAA+BI,SAA/B,GAA2CC,MAAM,CAACC,MAAP,CAAcP,OAAO,CAACE,QAAR,CAAiBG,SAA/B,CAA3C;;AAEAL,EAAAA,OAAO,CAACQ,yBAAR,CAAkCR,OAAO,CAACC,sBAAR,CAA+BI,SAAjE,EAA6E,YAAY;AAEvF,aAASI,aAAT,GAA0B;AACxB,UAAIC,YAAY,GAAG,CACjBV,OAAO,CAACW,MAAR,CAAeC,OAAf,CAAuBC,EADN,EAEjBb,OAAO,CAACW,MAAR,CAAeC,OAAf,CAAuBE,QAFN,EAGjBd,OAAO,CAACW,MAAR,CAAeC,OAAf,CAAuBG,KAHN,EAKjB,sDALiB,EAMjB,6BANiB,EAOjB,2CAPiB,EAQjB,GARiB,EAUjB,wEAViB,EAWjB,mCAXiB,EAYjB,sBAZiB,EAajB,8BAbiB,EAcjB,GAdiB,EAgBjB,8NAhBiB,EAkBjB,cAlBiB,EAmBjB,wCAnBiB,EAqBjB,4BArBiB,EAuBjB,iCAvBiB,EAwBjB,2CAxBiB,EAyBjB,mDAzBiB,EA2BjB,iDA3BiB,EA6BjB,0EA7BiB,EA8BjB,gHA9BiB,EA+BjB,oGA/BiB,EAkCjB,wDAlCiB,EAmCjB,wCAnCiB,EAqCjB,sCArCiB,EAsCjB,sCAtCiB,EAuCjB,6GAvCiB,EAwCjB,0EAxCiB,EA0CjB,gGA1CiB,EA2CjB,qGA3CiB,EA4CjB,wGA5CiB,EA6CjB,gHA7CiB,EA8CjB,0DA9CiB,EA+CjB,+EA/CiB,EAgDjB,8DAhDiB,EAkDjB,qCAlDiB,EAmDjB,uDAnDiB,EAoDjB,yCApDiB,EAqDjB,cArDiB,EAsDjB,yCAtDiB,EAuDjB,OAvDiB,EAyDjB,+CAzDiB,EA0DjB,+CA1DiB,EA2DjB,6IA3DiB,EA4DjB,6FA5DiB,EA8DjB,0CA9DiB,EA+DjB,kGA/DiB,EAkEjB,yCAlEiB,EAmEjB,wCAnEiB,EAqEjB,gDArEiB,EAsEjB,iIAtEiB,EAuEjB,sIAvEiB,EAyEjB,qGAzEiB,EA0EjB,kFA1EiB,EA2EjB,0FA3EiB,EA4EjB,6GA5EiB,EA+EjB,gCA/EiB,EAgFjB,wCAhFiB,EAkFjB,8DAlFiB,EAmFjB,8DAnFiB,EAqFjB,sHArFiB,EAsFjB,oCAtFiB,EAuFjB,wFAvFiB,EAwFjB,wFAxFiB,EAyFjB,OAzFiB,EA2FjB,4GA3FiB,EA8FjB,iCA9FiB,EA+FjB,wCA/FiB,EAiGjB,mHAjGiB,EAkGjB,yCAlGiB,EAmGjB,0HAnGiB,EAoGjB,OApGiB,EAqGjB,oHArGiB,EAwGjB,gDAxGiB,EAyGjB,wCAzGiB,EA2GjB,uGA3GiB,EA4GjB,uCA5GiB,EA6GjB,qBA7GiB,EA8GjB,OA9GiB,EAiHjB,gBAjHiB,EAkHjB,GAlHiB,EAqHjB,yDArHiB,EAsHjB,GAtHiB,EAuHjB,cAvHiB,EAwHjB,wCAxHiB,EA0HjB,8CA1HiB,EA4HjB,2GA5HiB,EA6HjB,gDA7HiB,EA8HjB,oDA9HiB,EAiIjB,mBAjIiB,EAkIjB,wCAlIiB,EAoIjB,mMApIiB,EAsIjB,2CAtIiB,EAuIjB,GAvIiB,EAwIjBC,IAxIiB,CAwIZ,IAxIY,CAAnB;AA0IA,aAAON,YAAP;AACD;;AAED,WAAO;AAELO,MAAAA,WAAW,EAAGjB,OAAO,CAACC,sBAFjB;AAILiB,MAAAA,IAAI,EAAG,gBAAY;AACjB,aAAKC,SAAL,GAAiBV,aAAa,EAA9B;AACA,aAAKW,QAAL,GAAgB;AACZC,UAAAA,kBAAkB,EAAG;AAAEC,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB,WADT;AAEZC,UAAAA,sBAAsB,EAAG;AAAEF,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB,WAFb;AAGZE,UAAAA,qBAAqB,EAAG;AAAEH,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB,WAHZ;AAIZG,UAAAA,uBAAuB,EAAG;AAAEJ,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB,WAJd;AAKZI,UAAAA,sBAAsB,EAAG;AAAEL,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB,WALb;AAMZK,UAAAA,gBAAgB,EAAG;AAAEN,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG,CAAC,GAAD,EAAM,GAAN;AAAvB,WANP;AAOZM,UAAAA,SAAS,EAAG;AAAEP,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAI;AAAxB,WAPA;AAQZO,UAAAA,MAAM,EAAG;AAAER,YAAAA,IAAI,EAAG,IAAT;AAAeC,YAAAA,KAAK,EAAG;AAAvB;AARG,SAAhB;AAUD;AAhBI,KAAP;AAmBD,GAnK2E,EAA5E;AAqKD,CA7KD,EA8KE,KAAKvB,OA9KP","file":"rollingDistortMaterial.b80b465f.js","sourceRoot":"..","sourcesContent":["(function(Blotter) {\n\n  Blotter.RollingDistortMaterial = function() {\n    Blotter.Material.apply(this, arguments);\n  };\n\n  Blotter.RollingDistortMaterial.prototype = Object.create(Blotter.Material.prototype);\n\n  Blotter._extendWithGettersSetters(Blotter.RollingDistortMaterial.prototype, (function () {\n\n    function _mainImageSrc () {\n      var mainImageSrc = [\n        Blotter.Assets.Shaders.PI,\n        Blotter.Assets.Shaders.LineMath,\n        Blotter.Assets.Shaders.Noise,\n\n        \"// Fix a floating point number to two decimal places\",\n        \"float toFixedTwo(float f) {\",\n        \"    return float(int(f * 100.0)) / 100.0;\",\n        \"}\",\n\n        \"// Via: http://www.iquilezles.org/www/articles/functions/functions.htm\",\n        \"float impulse(float k, float x) {\",\n        \"    float h = k * x;\",\n        \"    return h * exp(1.0 - h);\",\n        \"}\",\n\n        \"vec2 waveOffset(vec2 fragCoord, float sineDistortSpread, float sineDistortCycleCount, float sineDistortAmplitude, float noiseDistortVolatility, float noiseDistortAmplitude, vec2 distortPosition, float deg, float speed) {\",\n\n        \"    // Setup\",\n        \"    // -------------------------------\",\n\n        \"    deg = toFixedTwo(deg);\",\n\n        \"    float centerDistance = 0.5;\",\n        \"    vec2 centerUv = vec2(centerDistance);\",\n        \"    vec2 centerCoord = uResolution.xy * centerUv;\",\n\n        \"    float changeOverTime = uGlobalTime * speed;\",\n\n        \"    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);\",\n        \"    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\",\n        \"    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg), uResolution.xy);\",\n\n\n        \"    // Find intersects for line with edges of viewport\",\n        \"    // -------------------------------\",\n\n        \"    vec2 edgeIntersectA = vec2(0.0);\",\n        \"    vec2 edgeIntersectB = vec2(0.0);\",\n        \"    intersectsOnRectForLine(edgeIntersectA, edgeIntersectB, vec2(0.0), uResolution.xy, centerCoord, slope);\",\n        \"    float crossSectionLength = distance(edgeIntersectA, edgeIntersectB);\",\n\n        \"    // Find the threshold for degrees at which our intersectsOnRectForLine function would flip\",\n        \"    //   intersects A and B because of the order in which it finds them. This is the angle at which\",\n        \"    //   the y coordinate for the hypotenuse of a right triangle whose oposite adjacent edge runs from\",\n        \"    //   vec2(0.0, centerCoord.y) to centerCoord and whose opposite edge runs from vec2(0.0, centerCoord.y) to\",\n        \"    //   vec2(0.0, uResolution.y) exceeeds uResolution.y\",\n        \"    float thresholdDegA = atan(centerCoord.y / centerCoord.x) * (180.0 / PI);\",\n        \"    float thresholdDegB = mod(thresholdDegA + 180.0, 360.0);\",\n\n        \"    vec2 edgeIntersect = vec2(0.0);\",\n        \"    if (deg < thresholdDegA || deg > thresholdDegB) {\",\n        \"        edgeIntersect = edgeIntersectA;\",\n        \"    } else {\",\n        \"        edgeIntersect = edgeIntersectB;\",\n        \"    }\",\n\n        \"    vec2 perpendicularIntersectA = vec2(0.0);\",\n        \"    vec2 perpendicularIntersectB = vec2(0.0);\",\n        \"    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), uResolution.xy, centerCoord, perpendicularSlope); \",\n        \"    float perpendicularLength = distance(perpendicularIntersectA, perpendicularIntersectA);\",\n\n        \"    vec2 coordLineIntersect = vec2(0.0);\",\n        \"    lineLineIntersection(coordLineIntersect, centerCoord, slope, fragCoord, perpendicularSlope);\",\n\n\n        \"    // Define placement for distortion \",\n        \"    // -------------------------------\",\n\n        \"    vec2 distortPositionIntersect = vec2(0.0);\",\n        \"    lineLineIntersection(distortPositionIntersect, distortPosition * uResolution.xy, perpendicularSlope, edgeIntersect, slope);\",\n        \"    float distortDistanceFromEdge = (distance(edgeIntersect, distortPositionIntersect) / crossSectionLength);// + sineDistortSpread;\",\n\n        \"    float uvDistanceFromDistort = distance(edgeIntersect, coordLineIntersect) / crossSectionLength;\",\n        \"    float noiseDistortVarianceAdjuster = uvDistanceFromDistort + changeOverTime;\",\n        \"    uvDistanceFromDistort += -centerDistance + distortDistanceFromEdge + changeOverTime;\",\n        \"    uvDistanceFromDistort = mod(uvDistanceFromDistort, 1.0); // For sine, keep distance between 0.0 and 1.0\",\n\n\n        \"    // Define sine distortion \",\n        \"    // -------------------------------\",\n\n        \"    float minThreshold = centerDistance - sineDistortSpread;\",\n        \"    float maxThreshold = centerDistance + sineDistortSpread;\",\n\n        \"    uvDistanceFromDistort = clamp(((uvDistanceFromDistort - minThreshold)/(maxThreshold - minThreshold)), 0.0, 1.0);\",\n        \"    if (sineDistortSpread < 0.5) {\",\n        \"        // Add smoother decay to sin distort when it isnt taking up the full viewport.\",\n        \"        uvDistanceFromDistort = impulse(uvDistanceFromDistort, uvDistanceFromDistort);\",\n        \"    }\",\n\n        \"    float sineDistortion = sin(uvDistanceFromDistort * PI * sineDistortCycleCount) * sineDistortAmplitude;\",\n\n\n        \"    // Define noise distortion \",\n        \"    // -------------------------------\",\n\n        \"    float noiseDistortion = noise(noiseDistortVolatility * noiseDistortVarianceAdjuster) * noiseDistortAmplitude;\",\n        \"    if (noiseDistortVolatility > 0.0) {\",\n        \"        noiseDistortion -= noiseDistortAmplitude / 2.0; // Adjust primary distort so that it distorts in two directions.\",\n        \"    }\",\n        \"    noiseDistortion *= (sineDistortion > 0.0 ? 1.0 : -1.0); // Adjust primary distort to account for sin variance.\",\n\n\n        \"    // Combine distortions to find UV offsets \",\n        \"    // -------------------------------\",\n\n        \"    vec2 kV = offsetsForCoordAtDistanceOnSlope(sineDistortion + noiseDistortion, perpendicularSlope);\",\n        \"    if (deg <= 0.0 || deg >= 180.0) {\",\n        \"        kV *= -1.0;\",\n        \"    }\",\n\n\n        \"    return kV;\",\n        \"}\",\n\n\n        \"void mainImage( out vec4 mainImage, in vec2 fragCoord )\",\n        \"{\",\n        \"    // Setup\",\n        \"    // -------------------------------\",\n\n        \"    vec2 uv = fragCoord.xy / uResolution.xy;\",\n\n        \"    // Minor hacks to ensure our waves start horizontal and animating in a downward direction by default.\",\n        \"    uRotation = mod(uRotation + 270.0, 360.0);\",\n        \"    uDistortPosition.y = 1.0 - uDistortPosition.y;\",\n\n\n        \"    // Distortion\",\n        \"    // -------------------------------\",\n\n        \"    vec2 offset = waveOffset(fragCoord, uSineDistortSpread, uSineDistortCycleCount, uSineDistortAmplitude, uNoiseDistortVolatility, uNoiseDistortAmplitude, uDistortPosition, uRotation, uSpeed);\",\n\n        \"    mainImage = textTexture(uv + offset);\",\n        \"}\"\n      ].join(\"\\n\");\n\n      return mainImageSrc;\n    }\n\n    return {\n\n      constructor : Blotter.RollingDistortMaterial,\n\n      init : function () {\n        this.mainImage = _mainImageSrc();\n        this.uniforms = {\n            uSineDistortSpread : { type : \"1f\", value : 0.05 },\n            uSineDistortCycleCount : { type : \"1f\", value : 2.0 },\n            uSineDistortAmplitude : { type : \"1f\", value : 0.25 },\n            uNoiseDistortVolatility : { type : \"1f\", value : 20.0 },\n            uNoiseDistortAmplitude : { type : \"1f\", value : 0.01 },\n            uDistortPosition : { type : \"2f\", value : [0.5, 0.5] },\n            uRotation : { type : \"1f\", value :  170.0 },\n            uSpeed : { type : \"1f\", value : 0.08 }\n        };\n      }\n    };\n\n  })());\n\n})(\n  this.Blotter\n);\n"]}